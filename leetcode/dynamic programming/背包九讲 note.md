

### 0/1背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
每件物品只有一个
求背包最大价值

#### 思路
递归的思考问题：最终问题可以转换成求解子问题。最后一个物品放、或者不放。这样转换成求子问题：物品个数为N-1，容量V-vn，或者容量为V时，求背包最大价值。

子问题有重复计算，因此选用DP解题。
状态定义：$F[i][j]$前i个物品背包容量为j时的最大价值
状态转移：
$$F[i][j] = max(F[i-1][j], F[i-1][j-v[i]] + w[i] )$$

#### 伪代码，2维数组保存
```
F[0, 0....V] : 0
For i : 1 to N
    For j : v_i to V
        F[i][j] = maxF[i-1][j], F[i-1][j-v[i]] + w[i] )
```

    
    
#### 用1维数组保存

实际上，通过状态转移方程可以看出，只保存上一行的结果即可，因此用一维数组保存上一行结果，然后在本行的计算中，进行更新。但是因为计算中用到本列和之前的列，因此为了避免之前的列被改变，每行计算时选择从后往前刷表。
```
F[0, 0....V] :  0
    For i : 1 to N
        For j : V to v[i]
            F[j] = maxF[j-1], F [j-v[i] ] + w[i] )
```
定义一般0/1背包处理**一个**物品的函数：
```
def ZeroOnePack(F, C, W)
    For j : V to v[i]
        F[j] = maxF[j-1], F[ j-v[i] ] + w[i] )
```

伪代码变为
```
F[0, 0....V] :  0
    For i : 1 to N
        ZeroOnePack(F, v[i], W[i])
```
#### 边界条件，初始化
如果要求背包恰好装满：F[0] = 0, F[1...V] = 负无穷
如果不要求背包恰好装满： F[0...V] = 0
因为物品个数为0时，如果不要求装满，则所有容量的背包里的价值都为0；如果要求装满，则只有容量为0的背包满足被装满的条件，其他都不符合，因此设为负无穷。
这个方法适用于所有背包问题

#### 复杂度
时间：O(NV)
空间：O(V)


### 完全背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
每件物品有无数件
求背包最大价值

#### 思路
将每个物品拆分成V/v_i件，用01背包问题求解
时间复杂度$O(V*\sum V/v_i)$

#### 简单优化
若两个物品，v_i < v_j 且 w_i > w_j, 则不考虑j这个物品
利用计数排序，通过O(N+V)的时间复杂度实现

#### 利用二进制思维改善物品个数
对于任何一个物品，最多取V/V_i个，但是不需要一个一个取，实际上可以拆分成k **约等于** log2(V/V_i)个。也就是说，一共有k个物品，每个物品的价值和重量分别为本身乘以系数。具体拆分见多重背包。

#### 复杂度优化
之前01背包的状态转移：
$$F[i][j] = max(F[i-1][j], F[i-1][j-v[i]] + w[i] )$$
现在的状态转移
状态转移：
$$F[i][j] = max(F[i-1][j], F[i][j-v[i]] + w[i] )$$
区别就是可以取本行的数，因此如果转换成一维表的话，从前往后刷
$$F[j] = max(F[j], F[j-v[i]] + w[i] )$$

这样时间复杂度是O(NV)，空间复杂度O(V)

#### 伪代码
定义一般0/1背包处理**一个**物品的函数：
```
def CompletePack(F, C, W)
    For j : C to V
        F[j] = maxF[j-1], F[ j-C ] + W )
```

伪代码变为
```
F[0, 0....V] :  0
    For i : 1 to N
        CompletePack(F, v[i], W[i])
```

### 多重背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
每件物品最多可用Mi件
求背包最大价值

#### 思路
将每个物品拆分成Mi件，用01背包问题求解
时间复杂度$O(V*\sum M_i)$



#### 利用二进制思维改善物品个数
##### 这里很重要，刚开始就搞错了
对于任何一个物品，**最多**取Mi个，但是不需要一个一个取，实际上可以拆分成k 约等于 log2(Mi)个。
时间复杂度$O(V*\sum log2(M_i))$
**注意： 这里要拆分的时候尤其注意最后一个值，因为拆分后的各个物品的数量组合不能超过Mi**
比如Mi = 13， 那么拆分的k等于1， 2， 4， **6**，而不是1,2,4,8。
所以在2^k小于Mi时，物品的值就是k，每次k都乘以2
当2^k大于或者等于Mi时，物品的值就是 $M_i -(2^k -1)$


#### 伪代码
```
def MultiplePack(F, C, W, M)

    if M >= V/C
        CompletePack(F, C, W)
        return 
    n = 1
    while n < M
        ZeroOnePack(F, n*C, n*W)
        M -= n
        n = 2n
    //注意，此时对应 M == (2^k -1)
    ZeroOnePack(F, M*C, M*W)
    return 
        
```

### 特例
如果只需要填满背包，有复杂度O(NV)的算法


### 混合三种背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
有的物品有一个，有的Mi个，有的无限个
求背包最大价值


#### 思路
每种物品分别用不同的处理方法处理，根据上面3中处理不同物品的函数，循环所有物品，写出最终代码

#### 伪代码
```
F[0, 0....V] :  0
For i : 1 to N
    if i 属于01背包
        ZeroOnePack(F, v[i], W[i])
    elif i 属于完全背包
        CompletePack(F, v[i], W[i])
    elif i 属于多重背包
        MultiplePack(F, v[i], W[i]，M[i])
```


### 二维费用背包


### 分组背包


### 有依赖的背包




