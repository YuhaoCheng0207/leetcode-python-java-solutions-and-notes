

### 1. 0/1背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
每件物品只有一个
求背包最大价值

#### 思路
递归的思考问题：最终问题可以转换成求解子问题。最后一个物品放、或者不放。这样转换成求子问题：物品个数为N-1，容量V-vn，或者容量为V时，求背包最大价值。

子问题有重复计算，因此选用DP解题。
状态定义：$F[i][j]$前i个物品背包容量为j时的最大价值
状态转移：
$$F[i][j] = max(F[i-1][j], F[i-1][j-v[i]] + w[i] )$$

#### 伪代码，2维数组保存
```
F[0, 0....V] : 0
For i : 1 to N
    For j : v_i to V
        F[i][j] = maxF[i-1][j], F[i-1][j-v[i]] + w[i] )
```

    
    
#### 用1维数组保存

实际上，通过状态转移方程可以看出，只保存上一行的结果即可，因此用一维数组保存上一行结果，然后在本行的计算中，进行更新。但是因为计算中用到本列和之前的列，因此为了避免之前的列被改变，每行计算时选择从后往前刷表。
```
F[0, 0....V] :  0
    For i : 1 to N
        For j : V to v[i]
            F[j] = maxF[j-1], F [j-v[i] ] + w[i] )
```
定义一般0/1背包处理**一个**物品的函数：
```
def ZeroOnePack(F, C, W)
    For j : V to v[i]
        F[j] = maxF[j-1], F[ j-v[i] ] + w[i] )
```

伪代码变为
```
F[0, 0....V] :  0
    For i : 1 to N
        ZeroOnePack(F, v[i], W[i])
```
#### 边界条件，初始化
如果要求背包恰好装满：F[0] = 0, F[1...V] = 负无穷
如果不要求背包恰好装满： F[0...V] = 0
因为物品个数为0时，如果不要求装满，则所有容量的背包里的价值都为0；如果要求装满，则只有容量为0的背包满足被装满的条件，其他都不符合，因此设为负无穷。
这个方法适用于所有背包问题

#### 复杂度
时间：O(NV)
空间：O(V)


### 2. 完全背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
每件物品有无数件
求背包最大价值

#### 思路
将每个物品拆分成V/v_i件，用01背包问题求解
时间复杂度$O(V*\sum V/v_i)$

#### 简单优化
若两个物品，v_i < v_j 且 w_i > w_j, 则不考虑j这个物品
利用计数排序，通过O(N+V)的时间复杂度实现

#### 利用二进制思维改善物品个数
对于任何一个物品，最多取V/V_i个，但是不需要一个一个取，实际上可以拆分成k **约等于** log2(V/V_i)个。也就是说，一共有k个物品，每个物品的价值和重量分别为本身乘以系数。具体拆分见多重背包。

#### 复杂度优化
之前01背包的状态转移：
$$F[i][j] = max(F[i-1][j], F[i-1][j-v[i]] + w[i] )$$
现在的状态转移
状态转移：
$$F[i][j] = max(F[i-1][j], F[i][j-v[i]] + w[i] )$$
区别就是可以取本行的数，因此如果转换成一维表的话，从前往后刷
$$F[j] = max(F[j], F[j-v[i]] + w[i] )$$

这样时间复杂度是O(NV)，空间复杂度O(V)

#### 伪代码
定义一般0/1背包处理**一个**物品的函数：
```
def CompletePack(F, C, W)
    For j : C to V
        F[j] = maxF[j-1], F[ j-C ] + W )
```

伪代码变为
```
F[0, 0....V] :  0
    For i : 1 to N
        CompletePack(F, v[i], W[i])
```

### 3. 多重背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
每件物品最多可用Mi件
求背包最大价值

#### 思路
将每个物品拆分成Mi件，用01背包问题求解
时间复杂度$O(V*\sum M_i)$



#### 利用二进制思维改善物品个数
##### 这里很重要，刚开始就搞错了
对于任何一个物品，**最多**取Mi个，但是不需要一个一个取，实际上可以拆分成k 约等于 log2(Mi)个。
时间复杂度$O(V*\sum log2(M_i))$
**注意： 这里要拆分的时候尤其注意最后一个值，因为拆分后的各个物品的数量组合不能超过Mi**
比如Mi = 13， 那么拆分的k等于1， 2， 4， **6**，而不是1,2,4,8。
所以在2^k小于Mi时，物品的值就是k，每次k都乘以2
当2^k大于或者等于Mi时，物品的值就是 $M_i -(2^k -1)$


#### 伪代码
```
def MultiplePack(F, C, W, M)

    if M >= V/C
        CompletePack(F, C, W)
        return 
    n = 1
    while n < M
        ZeroOnePack(F, n*C, n*W)
        M -= n
        n = 2n
    //注意，此时对应 M == (2^k -1)
    ZeroOnePack(F, M*C, M*W)
    return 
        
```

### 特例
如果只需要填满背包，有复杂度O(NV)的算法


### 4. 混合三种背包问题
背包容量：V
物品个数：N
每件物品的体积：vi
每件物品的价值：wi
有的物品有一个，有的Mi个，有的无限个
求背包最大价值


#### 思路
每种物品分别用不同的处理方法处理，根据上面3中处理不同物品的函数，循环所有物品，写出最终代码

#### 伪代码
```
F[0, 0....V] :  0
For i : 1 to N
    if i 属于01背包
        ZeroOnePack(F, v[i], W[i])
    elif i 属于完全背包
        CompletePack(F, v[i], W[i])
    elif i 属于多重背包
        MultiplePack(F, v[i], W[i]，M[i])
```


### 5. 二维费用背包
每种物品有两种不同的费用
背包容量：V,U
物品个数：N
每件物品的费用：vi，ui
每件物品的价值：wi
求背包最大价值

#### 思路
加了一维费用，那么状态转移矩阵变为：
$$F[i][j][k] = max(F[i-1][j][k], F[i-1][j-v_i][k-u_i] + w_i)$$
#### 优化空间
将3维表格转换为2维，然后根据物品能取的件数来选择解法

#### 例子
有时题目会说，所有物品加起来，最多取U件。相当于加了个件数的维度，每个物品的费用为1

#### 特别思考：复数域上的问题
二维背包问题就是复数域上的一维背包问题，解法和一维背包问题一样

### 6. 分组背包

背包容量：V
物品个数：N
每件物品的费用：vi
每件物品的价值：wi
物品分为K组，每种物品互相冲突，只能选一个
求背包最大价值
#### 思路
考虑k组物品，每组物品选或者不选，那么状态F[i][j] 的意义是：考虑前i组，背包大小为j时，取到的最大价值

状态转移方程变为
$$F[i][j] = max(F[i-1][j], F[i-1][j - v[i]]| i \in group_i) $$

#### 伪代码
使用三层循环，保证每组最多只有一个物品被放进去
```
for i : 1 to K
    for j : V to 0
        for all item in group i
            F[j]= max(F[j] - F[j-v[i]] + w[i])
```
#### 类似于完全背包的优化
如果同一组的物品，价值高且重量低，则可以把比它差的物品删掉





### 7. 有依赖的背包
物品间有依赖关系，若选物品i，则必须选物品j，即i依赖于j，j是主件，i是附件。此处的限制条件是，附件没有自己的附件。所以该问题的物品由若干主件和依赖于主件的其余附件组成。

#### 思路
假设主件为k个，可以考虑一共有k组，每组选一种方案，代表该组的物品。但是每组假设有n个附件，那么一共有$2^n+1$种选择方案，即该组有$2^n+1$种物品，从中选一种。此时可以利用分组背包问题解决。

但是！

因为每组的物品（策略）太多了，因此该算法复杂度太高，还是有问题。
实际上还能再对组内进行优化。

首先可以考虑进行类似于完全背包的优化，将不好的附件直接扔掉。

然后更关键的：
考虑第k组的主件的体积为$v_k$，背包的总容量V，那么每组剩下的体积最大为$V-v_k$，对组内所有组合进行一个0/1背包，得到F[n][1]...F[n][V-v_k]，那么该组内实际的物品现在就变为了$V-v_k$个，再考虑取、不取主件，该组的物品实际为$V-v_k+1$个。该组内的01背包问题的时间复杂度是 $O((V-v_k)* n)$ 空间复杂度$O(V-v_k)$ 
经过该01背包优化后，组内的物品个数从$2^n+1$ 变成了$V-v_k+1$，此时可以采用**分组背包**的方法解决剩余的步骤。



#### 更一般的有依赖的背包

附件还有自己的附件，但是每个附件只依赖于一个主件。
先球子问题，再求父问题

### 8. 泛化物品



### 9. 背包问题问法的变化

#### 9.1 输出方案
一般DP只求最优值，但是如果输出方案，记录最优值是由哪个状态得出的。
以01背包举例：

定义一个矩阵G(N,V)
状态转移：
$$F[i][j] = max(F[i-1][j], F[i-1][j-v[i]] + w[i] )$$

每次求状态转移时，如果选前一项（没选i这个物品），则G(i, v) = 0, 否则G(i, v) = 1.
这样刷完表后，可以再进行如下过程：
```
i  =  N
j = V
while i < 0
    if G(i, v) = 0
        print 没选第i个
    else
        print 选了第i个
        j = V - i
    i = i - 1
```

或者不记录G数组，用F也能判断，即：
G(i, v) = 0 改为 F[i][v] = F[i-1][v]
G(i, v) = 1 改为 F[i][v] =  F[i-1][j-v[i]] + w[i] 

#### 9.2 输出字典序最小的最优方案
比如，01背包选最小字典序
因为状态转移方程变了，最好的办法是用之前的状态转移方程，但是物品的编号要变为 x = N + 1 - x，在选择完成后再把编号变回来。
注意在F[i-1][j]和 F[i-1][j-v[i]] + w[i]相等时，选择后者，即在此时选更大的编号的物品（最终方案中选择更小的编号）

#### 9.3 方案总数
对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，**除了再给定每个物品的价值后求可得到的最大价值外**，还可以得到**装满背包或将背包装至某一指定容量的方案总数**。
注意：这里不是非要求价值最大的方案，因此不需要关注最大价值，用F表示方案数即可

将状态转移方程中的max改为sum即可
$$F[i][j] = sum(F[i-1][j], F[i-1][j-v[i]] + w[i] )$$
初始条件是F[0][0] = 1
事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

#### 9.4 最优方案总数
这里是求得到物品最大总价值方案，但是不一定装满
此时F必须代表物品的总价值，那么久没有一个数组能存放方案数，因此再定义一个
G存方案数，随着F更新

##### 伪代码
```
G(0, 0) = 1
For i : 1 to N
    For j : 0 to V
        F[i, j] = max(F[i-1, j] , F[i-1, j-v_i] + w_i)
        G[i, j] = 0
        if F[i, j] = F[i-1, j] 
            G[i, j] = G[i, j] + G[i-1, j]
        if F[i, j] = F[i-1, j-v_i]
            G[i, j] = G[i, j] + G[i-1, j - v_i]

```
最终得到G[N, V]

#### 9.5 次优解或者第k优解
将每个状态表示成一个长为k的有序队列，从大到小排。
F[i, v] 这个有序队列是由 F[i − 1, v] 和 F[i − 1,v −vi] + Wi 这两个有序队列合并得到的，合并的方式是加到一起，求最大的k个解。
时间复杂度是O(KNV)，多出来的K是每次合并的时候用的


